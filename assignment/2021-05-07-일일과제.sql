-- 05/07 일일 과제
-- 1번
SELECT E.ENAME||' ''S MANAGER IS '||NVL(M.ENAME, 'NOBODY') AS MANAGER
FROM EMP E,EMP M 
WHERE E.MGR = M.EMPNO(+) 
ORDER BY M.ENAME;

SELECT E.ENAME||' ''S MANAGER IS '||M.ENAME AS MANAGER
FROM EMP E,EMP M 
WHERE E.MGR = M.EMPNO(+) 
ORDER BY M.ENAME;


-- 2번

-- MAKE_ENV.SQL
DROP TABLE SYSTEM;
COMMIT;
CREATE TABLE SYSTEM( SYSTEM_ID VARCHAR2(5),
SYSTEM_NAME VARCHAR2(11)
);
INSERT INTO SYSTEM VALUES('XXX','혜화DB');
INSERT INTO SYSTEM VALUES('YYY','강남DB');
INSERT INTO SYSTEM VALUES('ZZZ','영등포DB');
CREATE TABLE RESOURCE_USAGE(SYSTEM_ID
VARCHAR2(5), 
RESOURCE_NAME VARCHAR2(10)
);
INSERT INTO RESOURCE_USAGE VALUES('XXX','FTP');
INSERT INTO RESOURCE_USAGE VALUES('YYY','FTP');
INSERT INTO RESOURCE_USAGE VALUES('YYY','TELNET');
INSERT INTO RESOURCE_USAGE VALUES('YYY','EMAIL');
COMMIT;

SELECT * FROM SYSTEM;
SELECT * FROM RESOURCE_USAGE;


SELECT S.*, R.*
FROM SYSTEM S, RESOURCE_USAGE R
WHERE S.SYSTEM_ID = R.SYSTEM_ID(+);



SELECT S.SYSTEM_ID SYSTE, NULLIF(S.RESOURCE_USAGE) AS SYSTEM_NAME, R.FTP, R.TELNET, R.EMAIL
FROM SYSTEM S, RESOURCE_USAGE R
WHERE S.SYSTEM_ID = R.SYSTEM_ID;


-- 3번
-- JOIN을 사용하여 부서별 급여 지급 순위를 구하여라
-- EMPNO, ENAME, JOB, MGR, HIREDATE, SAL,COMM, DEPTNO

-- JOIN을 활용한 방법은?

-- 카디너리합 => 오류
SELECT E1.DEPTNO, E1.ENAME, E2.DEPTNO, E2.ENAME, E1.SAL, E2.SAL, E1.EMPNO,E1.JOB, E1.MGR, E1.HIREDATE, E1.COMM
FROM EMP E1, EMP E2
ORDER BY E1.DEPTNO, E1.ENAME;

SELECT E1.DEPTNO, E1.ENAME, E2.DEPTNO, E2.ENAME, E1.SAL, E2.SAL, E1.EMPNO,E1.JOB, E1.MGR, E1.HIREDATE, E1.COMM
FROM EMP E1, EMP E2
WHERE E1.DEPTNO = E2.DEPTNO
ORDER BY E1.DEPTNO, E1.ENAME;

SELECT E1.DEPTNO, E1.ENAME,E1.JOB, E2.DEPTNO, E2.ENAME,E2.JOB, E1.SAL, E2.SAL
FROM EMP E1, EMP E2
WHERE E1.DEPTNO = E2.DEPTNO
ORDER BY E1.DEPTNO, E1.ENAME;

SELECT E1.DEPTNO, E1.ENAME,E1.JOB, E2.DEPTNO, E2.ENAME,E2.JOB, E1.SAL, E2.SAL
FROM EMP E1, EMP E2
WHERE E1.DEPTNO = E2.DEPTNO
GROUP BY E1.DEPTNO, E1. ENAME, E1. JOB, E2.DEPTNO, E2.ENAME,E2.JOB, E1.SAL, E2.SAL
ORDER BY E1.DEPTNO, E1.ENAME;

SELECT E1.DEPTNO, E1.ENAME,E1.JOB, E2.DEPTNO, E2.ENAME,E2.JOB, E1.SAL, E2.SAL, COUNT(*)
FROM EMP E1, EMP E2
WHERE E1.DEPTNO = E2.DEPTNO
GROUP BY E1.DEPTNO, E1. ENAME, E1. JOB, E2.DEPTNO, E2.ENAME,E2.JOB, E1.SAL, E2.SAL
ORDER BY E1.DEPTNO, E1.ENAME;

SELECT E1.DEPTNO, E1.ENAME,E1.JOB, E1.SAL, COUNT(*)
FROM EMP E1, EMP E2
WHERE E1.DEPTNO = E2.DEPTNO AND E1.SAL <= E2.SAL 
GROUP BY E1.DEPTNO, E1. ENAME, E1. JOB, E1.SAL 
ORDER BY E1.DEPTNO, COUNT(*);

-- 최종 답안 : 틀림, 동률인 애들 한 번씩 더 구함
SELECT E1.DEPTNO, E1.ENAME,E1.JOB, E1.SAL, COUNT(*)
FROM EMP E1, EMP E2
WHERE E1.DEPTNO = E2.DEPTNO AND E1.SAL <= E2.SAL 
GROUP BY E1.DEPTNO, E1. ENAME, E1. JOB, E1.SAL
ORDER BY E1.DEPTNO, COUNT(*);

-- 예린이 풀이
SELECT E1.DEPTNO, E1.ENAME, E1.JOB, E1.SAL, 
    COUNT(DECODE(E1.DEPTNO, E2.DEPTNO,1)) + 1 as RANK 
FROM EMP E1, EMP E2
WHERE E1.SAL < E2.SAL(+)
GROUP BY E1.DEPTNO, E1.ENAME, E1.JOB, E1.SAL
ORDER BY DEPTNO, RANK;

-- 3.2 


SELECT DEPTNO, ENAME, JOB, SAL, 
    DENSE_RANK() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) AS GRADE
FROM EMP ORDER BY DEPTNO, SAL DESC;


-- RANK를 사용한 방법
SELECT DEPTNO, ENAME, JOB, SAL,
    RANK() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) RANK
FROM EMP ORDER BY DEPTNO;
