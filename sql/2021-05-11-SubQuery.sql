-- <05/10> 서브쿼리


-- 1. SMITH와 부서가 같은 애들을 출력하시오
SELECT ENAME,JOB
FROM EMP
WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'SMITH' );

-- 2. 전체 평균보다 급여가 작은 애들을 출력하시오
SELECT ENAME,SAL FROM EMP 
WHERE SAL < ( SELECT AVG(SAL) FROM EMP);

-- [SINGLE COLUMN, MULTIPLE ROW RETURN SUBQUERY]

-- 1~2.
SELECT ENAME,JOB FROM EMP WHERE DEPTNO = 10 OR DEPTNO = 30;

SELECT ENAME,JOB FROM EMP WHERE DEPTNO IN (10,30); -- // Multiple Rows



-- 그림 잘 이해하기
-- 3. 
-- WHERE 조건이 두 개 이상일 때는 = 대신 IN을 써야 한다.
SELECT DNAME,LOC FROM DEPT
WHERE DEPTNO = (SELECT DEPTNO FROM EMP GROUP BY DEPTNO HAVING COUNT(*) > 3 );

SELECT COUNT(*), DEPTNO FROM EMP GROUP BY DEPTNO HAVING COUNT(*) > 3;

SELECT DNAME,LOC FROM DEPT
WHERE DEPTNO IN (SELECT DEPTNO FROM EMP GROUP BY DEPTNO HAVING COUNT(*) > 3 );


-- 서브쿼리가 여러개의 컬럼을 리턴할 때 확인하기
-- 4. 급여 평균이 2000보다 많은 애들의 부서와 직무를 출력하시오
SELECT DEPTNO,JOB,ENAME,SAL FROM EMP
WHERE (DEPTNO,JOB) 
IN (SELECT DEPTNO,JOB FROM EMP
GROUP BY DEPTNO,JOB 
HAVING AVG(SAL) > 2000);

SELECT DEPTNO,JOB FROM EMP
GROUP BY DEPTNO,JOB 
HAVING AVG(SAL) > 2000;

-- [스칼라 서브쿼리]
-- SELECT LIST 자리에 서브쿼리가 올 때 

-- 5. 
SELECT DEPTNO,ENAME,JOB,SAL, 
(SELECT ROUND(AVG(SAL),0) FROM EMP S WHERE S.JOB=M.JOB) AS JOB_AVG_SAL 
FROM EMP M
ORDER BY JOB;


-- [CORRELATED SUBQUERY(상관서브쿼리)]
-- Corealted SubQuery : 메인쿼리가 실행된 후에야 서브쿼리를 사용할 수 있을 때!

-- 6.
SELECT DEPTNO,ENAME,JOB,SAL
FROM EMP M
WHERE SAL > ( SELECT AVG(SAL) AS AVG_SAL FROM EMP WHERE JOB = M.JOB );




-- [인라인 뷰]
-- 테이블은 정형화된 데이터 구조인데, 인라인뷰 서브쿼리를 사용하면 동적 테이블 구조를 생성해내서 활용할 수 있어서 편리하다.
-- 이때 활용한 동적 테이블 구조는 메모리 상에서만 실행되고 쿼리가 끝나면 사라진다. 
-- 정적 데이터 구조는 디스크 상에서 저장되어 사용된다는 차이가 있다. 

-- 7. 
SELECT DEPTNO, ENAME,EMP.JOB,SAL,IV.AVG_SAL
FROM EMP, (SELECT JOB,ROUND(AVG(SAL)) AS AVG_SAL FROM EMP GROUP BY JOB ) IV
WHERE EMP.JOB = IV.JOB AND SAL > IV.AVG_SAL
ORDER BY DEPTNO ,SAL DESC;

-- [1:M vs M:1]
SELECT * FROM SCOTT.EMP WHERE DEPTNO IN (SELECT DEPTNO FROM SCOTT.DEPT);

SELECT * FROM SCOTT.DEPT WHERE DEPTNO IN (SELECT DEPTNO FROM SCOTT.EMP);

SELECT * FROM EMP;
SELECT * FROM DEPT;

-- [TOP-N,BOTTOM-M]
SELECT * FROM 
( SELECT EMPNO,ENAME,SAL FROM EMP ORDER BY SAL ASC) BM
WHERE ROWNUM <= 5;


SELECT TN.EMPNO,TN.ENAME,TN.SAL FROM 
(SELECT EMPNO,ENAME,SAL FROM EMP ORDER BY SAL DESC) TN
WHERE ROWNUM < 5;
 


-- [DML]
-- SELECT가 서브쿼리 + INSERT가 메인 쿼리이다. 
INSERT INTO BONUS(ENAME,JOB,SAL,COMM)
SELECT ENAME,JOB,SAL,COMM FROM EMP;

ROLLBACK;

-- DML 내의 SELECT 문에는 DECODE, WHERE IN 등을 모두 사용할 수 있다.
INSERT INTO BONUS(ENAME,JOB,SAL,COMM)
SELECT ENAME,JOB,SAL,DECODE(DEPTNO,10,SAL*0.3,20,SAL*0.2)+NVL(COMM,0)
FROM EMP 
WHERE DEPTNO IN (10,20);

ROLLBACK;

-- 평상시에 COMM을 받지 못하는 사원들에게 평균 COMM 금액의 50%를 보너스로 지급
UPDATE EMP SET COMM = (SELECT AVG(COMM)/2 FROM EMP)
WHERE COMM IS NULL OR COMM = 0;

ROLLBACK;

-- 평균 이상의 급여를 받는 사원들은 보너스 지급 대상자에서 제외
DELETE FROM BONUS WHERE SAL > (SELECT AVG(SAL) FROM EMP) ;

ROLLBACK;