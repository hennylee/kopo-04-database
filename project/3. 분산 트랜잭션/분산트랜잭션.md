## 1. 분산 트랜잭션 정의
- 하나의 데이터베이스 인스턴스 내에서 한 트랜잭션으로 묶인 sql 문장이 모두 커밋되거나 롤백되듯이, 

- 네트워크로 연결된 여러 개의 데이터베이스 인스턴스가 참여하는 트랜잭션에서도 각각 다른 데이터베이스 인스턴스에서 수행한 SQL 문장이 
모두 동시에 커밋되거나 롤백되는 것을 '분산 트랜잭션(Distributed Transaction)'이라고 한다.  

- 즉, 여러 개의 노드 또는 다른 종류의 데이터베이스가 참여하는 하나의 트랜잭션을 '분산 트랜잭션(Distributed Transaction)'이라고 한다.


## 2. 2PC (2 Phase Commit) 이란?
- 2PC란 분산 컴퓨팅 환경에서 트랜잭션에 참여하는 모든 데이터베이스가 정상적으로 수정되었음을 보장하는 두 단계 커밋 프로토콜이다. 

- 2PC는 분산 트랜잭션에 참여한 모든 데이터베이스가 모두 함께 커밋되거나 롤백되는 것, 즉 원자성을 보장한다. 

- 2PC의 단계는 1) `First Phase(= prepare phase)` 와 2) `Second Phase(= commit phase)` 로 이루어져 있다. 

### 2.1 2PC의 단계

#### 1) First Phase(또는 prepare phase)

- First Phase는 각 데이터베이스 노드에 커밋을 하기 위한 준비 요청 단계이다.

- 다음은 First Phase가 실행되는 과정이다.

  - TM은 각 데이터베이스 노드에 커밋을 준비하라는 prepare 메시지를 보낸다.

  - 요청을 받은 각 데이터베이스는 커밋을 준비한다.

  - 커밋을 하기 위한 준비 작업에는 필요한 리소스에 잠금(Lock)을 설정하거나 로그 파일을 저장하는 작업 등이 있다.

  - 각 데이터베이스는 커밋 준비 여부에 따라 TM에 성공 또는 실패 여부를 알린다.
  
  - 커밋 준비가 모두 끝나면 prepare가 성공한 것이고, 커밋 준비를 실패하면 prepare가 실패한 것이다.

#### 2) Second Phase(또는 commit phase)

- TM은 참여한 모든 데이터베이스 노드로부터 prepare의 완료 메시지를 받을 때까지 대기한다.

- 이 단계에서는 전달 받은 prepare의 메시지에 따라 해당 결과가 다르다.

  - 롤백	: 한 데이터베이스 노드라도 prepare ok 메시지를 받지 않으면 이 트랜잭션은 커밋할 수 없다고 판단하고, 모든 데이터베이스 노드에 롤백 메시지를 보내 해당 작업을 롤백한다.
  
  - 커밋	: 모든 데이터베이스 노드로부터 prepare ok 메시지를 받으면 다시 모든 데이터베이스 노드에 커밋 메시지를 보내고 모든 작업을 커밋한다.


## 3. 2PL (2 Phase Locking) 이란?

- 직렬성 보장을 통해 동시성을 제어하는 2단계 로킹 프로토콜이다. 

- 2PL은 모든 트랜잭션들이 1) `잠금을 설정하는 단계(Lock)`와 `해제하는 단계(Unlock)`로 나누어 수행한다.

- 초기에는 트랜잭션이 growing phase 이다. 

- 그리고 락이 하나 풀린다면 Shrinking Phase에 들어가서 락을 더 이상 걸수는 없게 만드는 것이다. 

- 하지만 여기서도 데드락이 발생할 수는 있지만 적어도 conflict serializability(충돌 직렬 가능성)는 보장한다. 

  - 충돌직렬가능성이란? 
  - 서로 다른 트랜잭션에서 동일한 자원에 대해 연속적으로 읽기 / 읽기를 제외한 쓰기(write)가 하나라도 발생하면 충돌입니다. 
  - (읽기/쓰기, 쓰기/읽기, 쓰기/쓰기) 이런 충돌이 순환 사이클을 그리는 경우을 말합니다.

- 데드락이 발생하면 롤백 시킨다.

### 3.1 2PL의 단계

- Growing Phase (확장단계) : Lock을 수행할 수는 있지만 풀 수는 없다.

- Shrinking Phase (수축단계) : Lock을 수행할 수는 없지만 풀 수는 있다. 


![image](https://user-images.githubusercontent.com/77392444/120960723-65646700-c797-11eb-8384-2a37d5d2eed7.png)


Transaction T1:

- The growing Phase is from steps 1-3.
- The shrinking Phase is from steps 5-7.
- Lock Point at 3


Transaction T2:

- The growing Phase is from steps 2-6.
- The shrinking Phase is from steps 8-9.
- Lock Point at 6



LOCK POINT는 무엇인가? 
- The Point at which the growing phase ends 
- when a transaction takes the final lock it needs to carry on its work. 

Cascading Rollbacks in 2-PL – 

![image](https://user-images.githubusercontent.com/77392444/120961666-37802200-c799-11eb-81b5-e8d968fb237e.png)

- because of Dirty Read in T2 and T3 in lines 8 and 12 respectively, when T1 failed we have to roll back others also. 

- Hence, Cascading Rollbacks are possible in 2-PL. 

- When explained with real-time transaction problems with many variables, it becomes very complex. 


Deadlock in 2-PL – 

`Schedule:   Lock-X1(A)   Lock-X2(B)  Lock-X1(B)  Lock-X2(A)`

- Drawing the precedence graph, you may detect the loop. So Deadlock is also possible in 2-PL. 

- Two-phase locking may also limit the amount of concurrency that occurs in a schedule 
because a Transaction may not be able to release an item after it has used it. 

- This may be because of the protocols and other restrictions we may put on the schedule to ensure serializability, deadlock freedom, and other factors. 

- This is the price we have to pay to ensure serializability and other factors, hence it can be considered as a bargain between concurrency and maintaining the ACID properties. 

- The above-mentioned type of 2-PL is called Basic 2PL. 

-  To sum it up it ensures Conflict Serializability but does not prevent Cascading Rollback and Deadlock. 




### 3.2 2PL의 2가지 유형

#### 1) Strict two-phase locking protocol

- casecading rollback을 방지한다. (cascade rollback의 원인은 commit되지 않은 것들을 읽어서 발생한다.)

- exclusive lock이 commit되지 않은 데이터에 접근을 하지 못하게 한다.


#### 2) Rigorous two-phase locking protocol

- 모든 lock이 commit되지 않은 데이터에 접근을 하지 못하게 한다.

- 이 유형은 상용 db에서 많이 쓰인다.






## 4. 동형 DBMS (Oracle – Oracle) 사이의 분산 트랜잭션 구현하기 위한 방법을 간단하게  설명


### A homogenous distributed database system(동형 분산 데이터베이스 시스템) 이란?

![image](https://user-images.githubusercontent.com/77392444/120968139-731fe980-c7a3-11eb-8df9-f79738d4a2ef.png)

A homogenous distributed database system is a network of two or more Oracle
Databases that reside on one or more machines. 

Figure 29–1 illustrates a distributed system that connects three databases: hq, mfg, and sales. 

An application can simultaneously access or modify the data in several databases in a single distributed
environment. 

For example, a single query from a Manufacturing client on local database mfg can retrieve joined data from the products table on the local database
and the dept table on the remote hq database.

For a client application, the location and platform of the databases are transparent.

You can also create synonyms for remote objects in the distributed system so that users can access them with the same syntax as local objects. 

For example, if you are connected to database mfg 
but want to access data on database hq, creating a synonym on mfg for the remote dept table enables you to issue this query:

`SELECT * FROM dept`

In this way, a distributed system gives the appearance of native data access. 

Users on mfg do not have to know that the data they access resides on remote databases.



### Managing a Distributed Database

### Global Database Name 부여하기

```sql
SELECT * FROM GLOBAL_NAME; -- GLOBAL_NAME data dictionary 

SELECT NAME, VALUE FROM V$PARAMETER WHERE NAME = 'db_domain';

CREATE DATABASE LINK hq USING 'sales'; -- hq에 dblink 생성
SELECT DB_LINK FROM USER_DB_LINKS; -- dblink 확인

ALTER DATABASE RENAME GLOBAL_NAME TO sales.jp.acme.com; -- GLOBAL_NAME 변경하기
SELECT * FROM GLOBAL_NAME; 

SELECT NAME, VALUE FROM V$PARAMETER WHERE NAME = 'db_domain'; -- db_domain은 안바뀜

CREATE DATABASE LINK supply USING 'supply'; -- supply dblink 생성
SELECT DB_LINK FROM USER_DB_LINKS; -- dblink 확인

ALTER DATABASE RENAME GLOBAL_NAME TO sales.asia.jp.acme.com;
SELECT * FROM GLOBAL_NAME; 

SELECT NAME, VALUE FROM V$PARAMETER WHERE NAME = 'db_domain';

CREATE DATABASE LINK warehouse USING 'warehouse';
SELECT DB_LINK FROM USER_DB_LINKS;
```

### Creating Database Links

#### Obtaining Privileges Necessary for Creating Database Links

|Privilege |Database |Required For|
|----------|----------|-----------|
|CREATE DATABASE LINK |Local |Creation of a private database link.|
|CREATE PUBLIC DATABASE LINK |Local |Creation of a public database link.|
|CREATE SESSION |Remote |Creation of any type of database link.|
 
- 현재 가능한 권한 확인하기

```sql
SELECT DISTINCT PRIVILEGE AS "Database Link Privileges"
FROM ROLE_SYS_PRIVS
WHERE PRIVILEGE IN ( 'CREATE SESSION','CREATE DATABASE LINK',
'CREATE PUBLIC DATABASE LINK');
```

#### Specifying Link Types

- Creating Private Database Links

- Creating Public Database Links

- Creating Global Database Links

#### Specifying Link Users
  
#### Using Connection Qualifiers to Specify Service Names Within Link Names


## 5. 이형 DBMS (Oracle – SQL Server) 사이의 분산 트랜잭션 구현하기 위한 방법을 간단하게  설명

https://dbrang.tistory.com/468


##  개인 Local PC내의 Oracle DBMS 와  서버실의 Oracle DBMS간에 DB Link 생성 SQL  작성 

## 분산 트랜잭션 구현 시나리오 각자 작성
- 시나리오 설명
- 관련 테이블을 각각  2개의 DBMS내에 분산 생성 SQL 작성 , 샘플 데이터 생성 SQL 
- 분산 트랜잭션 SQL 작성 , SELECT문 작성 
